// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package hbase2go

import (
	"bytes"
	"fmt"

	"github.com/lightstep/lightstep-tracer-go/thrift_0_9_2/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type THBaseService interface {
	// Test for the existence of columns in the table, as specified in the TGet.
	//
	// @return true if the specified TGet matches one or more keys, false if not
	//
	// Parameters:
	//  - Table: the table to check on
	//  - Get: the TGet to check for
	Exists(table []byte, get *TGet) (r bool, err error)
	// Method for getting data from a row.
	//
	// If the row cannot be found an empty Result is returned.
	// This can be checked by the empty field of the TResult
	//
	// @return the result
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Get: the TGet to fetch
	Get(table []byte, get *TGet) (r *TResult_, err error)
	// Method for getting multiple rows.
	//
	// If a row cannot be found there will be a null
	// value in the result list for that TGet at the
	// same position.
	//
	// So the Results are in the same order as the TGets.
	//
	// Parameters:
	//  - Table: the table to get from
	//  - Gets: a list of TGets to fetch, the Result list
	// will have the Results at corresponding positions
	// or null if there was an error
	GetMultiple(table []byte, gets []*TGet) (r []*TResult_, err error)
	// Commit a TPut to a table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Put: the TPut to put
	Put(table []byte, put *TPut) (err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the TPut.
	//
	// @return true if the new put was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and put to
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - Put: the TPut to put if the check succeeds
	CheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, put *TPut) (r bool, err error)
	// Commit a List of Puts to the table.
	//
	// Parameters:
	//  - Table: the table to put data in
	//  - Puts: a list of TPuts to commit
	PutMultiple(table []byte, puts []*TPut) (err error)
	// Deletes as specified by the TDelete.
	//
	// Note: "delete" is a reserved keyword and cannot be used in Thrift
	// thus the inconsistent naming scheme from the other functions.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - DeleteSingle: the TDelete to delete
	DeleteSingle(table []byte, deleteSingle *TDelete) (err error)
	// Bulk commit a List of TDeletes to the table.
	//
	// Throws a TIOError if any of the deletes fail.
	//
	// Always returns an empty list for backwards compatibility.
	//
	// Parameters:
	//  - Table: the table to delete from
	//  - Deletes: list of TDeletes to delete
	DeleteMultiple(table []byte, deletes []*TDelete) (r []*TDelete, err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the delete.
	//
	// @return true if the new delete was executed, false otherwise
	//
	// Parameters:
	//  - Table: to check in and delete from
	//  - Row: row to check
	//  - Family: column family to check
	//  - Qualifier: column qualifier to check
	//  - Value: the expected value, if not provided the
	// check is for the non-existence of the
	// column in question
	//  - DeleteSingle: the TDelete to execute if the check succeeds
	CheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, deleteSingle *TDelete) (r bool, err error)
	// Parameters:
	//  - Table: the table to increment the value on
	//  - Increment: the TIncrement to increment
	Increment(table []byte, increment *TIncrement) (r *TResult_, err error)
	// Parameters:
	//  - Table: the table to append the value on
	//  - Append: the TAppend to append
	Append(table []byte, append *TAppend) (r *TResult_, err error)
	// Get a Scanner for the provided TScan object.
	//
	// @return Scanner Id to be used with other scanner procedures
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Scan: the scan object to get a Scanner for
	OpenScanner(table []byte, scan *TScan) (r int32, err error)
	// Grabs multiple rows from a Scanner.
	//
	// @return Between zero and numRows TResults
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
	//  - NumRows: number of rows to return
	GetScannerRows(scannerId int32, numRows int32) (r []*TResult_, err error)
	// Closes the scanner. Should be called to free server side resources timely.
	// Typically close once the scanner is not needed anymore, i.e. after looping
	// over it to get all the required rows.
	//
	// Parameters:
	//  - ScannerId: the Id of the Scanner to close *
	CloseScanner(scannerId int32) (err error)
	// mutateRow performs multiple mutations atomically on a single row.
	//
	// Parameters:
	//  - Table: table to apply the mutations
	//  - RowMutations: mutations to apply
	MutateRow(table []byte, rowMutations *TRowMutations) (err error)
	// Get results for the provided TScan object.
	// This helper function opens a scanner, get the results and close the scanner.
	//
	// @return between zero and numRows TResults
	//
	// Parameters:
	//  - Table: the table to get the Scanner for
	//  - Scan: the scan object to get a Scanner for
	//  - NumRows: number of rows to return
	GetScannerResults(table []byte, scan *TScan, numRows int32) (r []*TResult_, err error)
}

type THBaseServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewTHBaseServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *THBaseServiceClient {
	return &THBaseServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewTHBaseServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *THBaseServiceClient {
	return &THBaseServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Test for the existence of columns in the table, as specified in the TGet.
//
// @return true if the specified TGet matches one or more keys, false if not
//
// Parameters:
//  - Table: the table to check on
//  - Get: the TGet to check for
func (p *THBaseServiceClient) Exists(table []byte, get *TGet) (r bool, err error) {
	if err = p.sendExists(table, get); err != nil {
		return
	}
	return p.recvExists()
}

func (p *THBaseServiceClient) sendExists(table []byte, get *TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("exists", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ExistsArgs{
		Table: table,
		Get:   get,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvExists() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error21 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error22 error
		error22, err = error21.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error22
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "exists failed: out of sequence response")
		return
	}
	result := ExistsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Method for getting data from a row.
//
// If the row cannot be found an empty Result is returned.
// This can be checked by the empty field of the TResult
//
// @return the result
//
// Parameters:
//  - Table: the table to get from
//  - Get: the TGet to fetch
func (p *THBaseServiceClient) Get(table []byte, get *TGet) (r *TResult_, err error) {
	if err = p.sendGet(table, get); err != nil {
		return
	}
	return p.recvGet()
}

func (p *THBaseServiceClient) sendGet(table []byte, get *TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetArgs{
		Table: table,
		Get:   get,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGet() (value *TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error23 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error24 error
		error24, err = error23.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error24
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	result := GetResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Method for getting multiple rows.
//
// If a row cannot be found there will be a null
// value in the result list for that TGet at the
// same position.
//
// So the Results are in the same order as the TGets.
//
// Parameters:
//  - Table: the table to get from
//  - Gets: a list of TGets to fetch, the Result list
// will have the Results at corresponding positions
// or null if there was an error
func (p *THBaseServiceClient) GetMultiple(table []byte, gets []*TGet) (r []*TResult_, err error) {
	if err = p.sendGetMultiple(table, gets); err != nil {
		return
	}
	return p.recvGetMultiple()
}

func (p *THBaseServiceClient) sendGetMultiple(table []byte, gets []*TGet) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getMultiple", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetMultipleArgs{
		Table: table,
		Gets:  gets,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetMultiple() (value []*TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error25 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error26 error
		error26, err = error25.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error26
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getMultiple failed: out of sequence response")
		return
	}
	result := GetMultipleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Commit a TPut to a table.
//
// Parameters:
//  - Table: the table to put data in
//  - Put: the TPut to put
func (p *THBaseServiceClient) Put(table []byte, put *TPut) (err error) {
	if err = p.sendPut(table, put); err != nil {
		return
	}
	return p.recvPut()
}

func (p *THBaseServiceClient) sendPut(table []byte, put *TPut) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("put", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := PutArgs{
		Table: table,
		Put:   put,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvPut() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error27 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error28 error
		error28, err = error27.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error28
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "put failed: out of sequence response")
		return
	}
	result := PutResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the TPut.
//
// @return true if the new put was executed, false otherwise
//
// Parameters:
//  - Table: to check in and put to
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - Put: the TPut to put if the check succeeds
func (p *THBaseServiceClient) CheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, put *TPut) (r bool, err error) {
	if err = p.sendCheckAndPut(table, row, family, qualifier, value, put); err != nil {
		return
	}
	return p.recvCheckAndPut()
}

func (p *THBaseServiceClient) sendCheckAndPut(table []byte, row []byte, family []byte, qualifier []byte, value []byte, put *TPut) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkAndPut", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CheckAndPutArgs{
		Table:     table,
		Row:       row,
		Family:    family,
		Qualifier: qualifier,
		Value:     value,
		Put:       put,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCheckAndPut() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error29 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error30 error
		error30, err = error29.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error30
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndPut failed: out of sequence response")
		return
	}
	result := CheckAndPutResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Commit a List of Puts to the table.
//
// Parameters:
//  - Table: the table to put data in
//  - Puts: a list of TPuts to commit
func (p *THBaseServiceClient) PutMultiple(table []byte, puts []*TPut) (err error) {
	if err = p.sendPutMultiple(table, puts); err != nil {
		return
	}
	return p.recvPutMultiple()
}

func (p *THBaseServiceClient) sendPutMultiple(table []byte, puts []*TPut) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("putMultiple", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := PutMultipleArgs{
		Table: table,
		Puts:  puts,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvPutMultiple() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error31 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error32 error
		error32, err = error31.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error32
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "putMultiple failed: out of sequence response")
		return
	}
	result := PutMultipleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Deletes as specified by the TDelete.
//
// Note: "delete" is a reserved keyword and cannot be used in Thrift
// thus the inconsistent naming scheme from the other functions.
//
// Parameters:
//  - Table: the table to delete from
//  - DeleteSingle: the TDelete to delete
func (p *THBaseServiceClient) DeleteSingle(table []byte, deleteSingle *TDelete) (err error) {
	if err = p.sendDeleteSingle(table, deleteSingle); err != nil {
		return
	}
	return p.recvDeleteSingle()
}

func (p *THBaseServiceClient) sendDeleteSingle(table []byte, deleteSingle *TDelete) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteSingle", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteSingleArgs{
		Table:        table,
		DeleteSingle: deleteSingle,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDeleteSingle() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error33 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error34 error
		error34, err = error33.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error34
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteSingle failed: out of sequence response")
		return
	}
	result := DeleteSingleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Bulk commit a List of TDeletes to the table.
//
// Throws a TIOError if any of the deletes fail.
//
// Always returns an empty list for backwards compatibility.
//
// Parameters:
//  - Table: the table to delete from
//  - Deletes: list of TDeletes to delete
func (p *THBaseServiceClient) DeleteMultiple(table []byte, deletes []*TDelete) (r []*TDelete, err error) {
	if err = p.sendDeleteMultiple(table, deletes); err != nil {
		return
	}
	return p.recvDeleteMultiple()
}

func (p *THBaseServiceClient) sendDeleteMultiple(table []byte, deletes []*TDelete) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteMultiple", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteMultipleArgs{
		Table:   table,
		Deletes: deletes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvDeleteMultiple() (value []*TDelete, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error35 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error36 error
		error36, err = error35.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error36
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteMultiple failed: out of sequence response")
		return
	}
	result := DeleteMultipleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the delete.
//
// @return true if the new delete was executed, false otherwise
//
// Parameters:
//  - Table: to check in and delete from
//  - Row: row to check
//  - Family: column family to check
//  - Qualifier: column qualifier to check
//  - Value: the expected value, if not provided the
// check is for the non-existence of the
// column in question
//  - DeleteSingle: the TDelete to execute if the check succeeds
func (p *THBaseServiceClient) CheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, deleteSingle *TDelete) (r bool, err error) {
	if err = p.sendCheckAndDelete(table, row, family, qualifier, value, deleteSingle); err != nil {
		return
	}
	return p.recvCheckAndDelete()
}

func (p *THBaseServiceClient) sendCheckAndDelete(table []byte, row []byte, family []byte, qualifier []byte, value []byte, deleteSingle *TDelete) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkAndDelete", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CheckAndDeleteArgs{
		Table:        table,
		Row:          row,
		Family:       family,
		Qualifier:    qualifier,
		Value:        value,
		DeleteSingle: deleteSingle,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCheckAndDelete() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error37 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error38 error
		error38, err = error37.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error38
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndDelete failed: out of sequence response")
		return
	}
	result := CheckAndDeleteResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Table: the table to increment the value on
//  - Increment: the TIncrement to increment
func (p *THBaseServiceClient) Increment(table []byte, increment *TIncrement) (r *TResult_, err error) {
	if err = p.sendIncrement(table, increment); err != nil {
		return
	}
	return p.recvIncrement()
}

func (p *THBaseServiceClient) sendIncrement(table []byte, increment *TIncrement) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("increment", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := IncrementArgs{
		Table:     table,
		Increment: increment,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvIncrement() (value *TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error39 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error40 error
		error40, err = error39.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error40
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "increment failed: out of sequence response")
		return
	}
	result := IncrementResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Table: the table to append the value on
//  - Append: the TAppend to append
func (p *THBaseServiceClient) Append(table []byte, append *TAppend) (r *TResult_, err error) {
	if err = p.sendAppend(table, append); err != nil {
		return
	}
	return p.recvAppend()
}

func (p *THBaseServiceClient) sendAppend(table []byte, append *TAppend) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("append", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AppendArgs{
		Table:  table,
		Append: append,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvAppend() (value *TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error41 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error42 error
		error42, err = error41.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error42
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "append failed: out of sequence response")
		return
	}
	result := AppendResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get a Scanner for the provided TScan object.
//
// @return Scanner Id to be used with other scanner procedures
//
// Parameters:
//  - Table: the table to get the Scanner for
//  - Scan: the scan object to get a Scanner for
func (p *THBaseServiceClient) OpenScanner(table []byte, scan *TScan) (r int32, err error) {
	if err = p.sendOpenScanner(table, scan); err != nil {
		return
	}
	return p.recvOpenScanner()
}

func (p *THBaseServiceClient) sendOpenScanner(table []byte, scan *TScan) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("openScanner", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := OpenScannerArgs{
		Table: table,
		Scan:  scan,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvOpenScanner() (value int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		error44, err = error43.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error44
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "openScanner failed: out of sequence response")
		return
	}
	result := OpenScannerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Grabs multiple rows from a Scanner.
//
// @return Between zero and numRows TResults
//
// Parameters:
//  - ScannerId: the Id of the Scanner to return rows from. This is an Id returned from the openScanner function.
//  - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerRows(scannerId int32, numRows int32) (r []*TResult_, err error) {
	if err = p.sendGetScannerRows(scannerId, numRows); err != nil {
		return
	}
	return p.recvGetScannerRows()
}

func (p *THBaseServiceClient) sendGetScannerRows(scannerId int32, numRows int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getScannerRows", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetScannerRowsArgs{
		ScannerId: scannerId,
		NumRows:   numRows,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetScannerRows() (value []*TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error45 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error46 error
		error46, err = error45.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error46
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getScannerRows failed: out of sequence response")
		return
	}
	result := GetScannerRowsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	value = result.GetSuccess()
	return
}

// Closes the scanner. Should be called to free server side resources timely.
// Typically close once the scanner is not needed anymore, i.e. after looping
// over it to get all the required rows.
//
// Parameters:
//  - ScannerId: the Id of the Scanner to close *
func (p *THBaseServiceClient) CloseScanner(scannerId int32) (err error) {
	if err = p.sendCloseScanner(scannerId); err != nil {
		return
	}
	return p.recvCloseScanner()
}

func (p *THBaseServiceClient) sendCloseScanner(scannerId int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("closeScanner", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CloseScannerArgs{
		ScannerId: scannerId,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvCloseScanner() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		error48, err = error47.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error48
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "closeScanner failed: out of sequence response")
		return
	}
	result := CloseScannerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	return
}

// mutateRow performs multiple mutations atomically on a single row.
//
// Parameters:
//  - Table: table to apply the mutations
//  - RowMutations: mutations to apply
func (p *THBaseServiceClient) MutateRow(table []byte, rowMutations *TRowMutations) (err error) {
	if err = p.sendMutateRow(table, rowMutations); err != nil {
		return
	}
	return p.recvMutateRow()
}

func (p *THBaseServiceClient) sendMutateRow(table []byte, rowMutations *TRowMutations) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRow", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MutateRowArgs{
		Table:        table,
		RowMutations: rowMutations,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvMutateRow() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error49 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error50 error
		error50, err = error49.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error50
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRow failed: out of sequence response")
		return
	}
	result := MutateRowResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Get results for the provided TScan object.
// This helper function opens a scanner, get the results and close the scanner.
//
// @return between zero and numRows TResults
//
// Parameters:
//  - Table: the table to get the Scanner for
//  - Scan: the scan object to get a Scanner for
//  - NumRows: number of rows to return
func (p *THBaseServiceClient) GetScannerResults(table []byte, scan *TScan, numRows int32) (r []*TResult_, err error) {
	if err = p.sendGetScannerResults(table, scan, numRows); err != nil {
		return
	}
	return p.recvGetScannerResults()
}

func (p *THBaseServiceClient) sendGetScannerResults(table []byte, scan *TScan, numRows int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getScannerResults", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetScannerResultsArgs{
		Table:   table,
		Scan:    scan,
		NumRows: numRows,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *THBaseServiceClient) recvGetScannerResults() (value []*TResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error51 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error52 error
		error52, err = error51.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error52
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getScannerResults failed: out of sequence response")
		return
	}
	result := GetScannerResultsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

type THBaseServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      THBaseService
}

func (p *THBaseServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *THBaseServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *THBaseServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewTHBaseServiceProcessor(handler THBaseService) *THBaseServiceProcessor {

	self53 := &THBaseServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self53.processorMap["exists"] = &tHBaseServiceProcessorExists{handler: handler}
	self53.processorMap["get"] = &tHBaseServiceProcessorGet{handler: handler}
	self53.processorMap["getMultiple"] = &tHBaseServiceProcessorGetMultiple{handler: handler}
	self53.processorMap["put"] = &tHBaseServiceProcessorPut{handler: handler}
	self53.processorMap["checkAndPut"] = &tHBaseServiceProcessorCheckAndPut{handler: handler}
	self53.processorMap["putMultiple"] = &tHBaseServiceProcessorPutMultiple{handler: handler}
	self53.processorMap["deleteSingle"] = &tHBaseServiceProcessorDeleteSingle{handler: handler}
	self53.processorMap["deleteMultiple"] = &tHBaseServiceProcessorDeleteMultiple{handler: handler}
	self53.processorMap["checkAndDelete"] = &tHBaseServiceProcessorCheckAndDelete{handler: handler}
	self53.processorMap["increment"] = &tHBaseServiceProcessorIncrement{handler: handler}
	self53.processorMap["append"] = &tHBaseServiceProcessorAppend{handler: handler}
	self53.processorMap["openScanner"] = &tHBaseServiceProcessorOpenScanner{handler: handler}
	self53.processorMap["getScannerRows"] = &tHBaseServiceProcessorGetScannerRows{handler: handler}
	self53.processorMap["closeScanner"] = &tHBaseServiceProcessorCloseScanner{handler: handler}
	self53.processorMap["mutateRow"] = &tHBaseServiceProcessorMutateRow{handler: handler}
	self53.processorMap["getScannerResults"] = &tHBaseServiceProcessorGetScannerResults{handler: handler}
	return self53
}

func (p *THBaseServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x54 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x54.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x54

}

type tHBaseServiceProcessorExists struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorExists) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExistsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("exists", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExistsResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.Exists(args.Table, args.Get); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exists: "+err2.Error())
			oprot.WriteMessageBegin("exists", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("exists", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGet struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetResult{}
	var err2 error
	if result.Success, err2 = p.handler.Get(args.Table, args.Get); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetMultipleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetMultipleResult{}
	var err2 error
	if result.Success, err2 = p.handler.GetMultiple(args.Table, args.Gets); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getMultiple: "+err2.Error())
			oprot.WriteMessageBegin("getMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPut) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := PutArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := PutResult{}
	var err2 error
	if err2 = p.handler.Put(args.Table, args.Put); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing put: "+err2.Error())
			oprot.WriteMessageBegin("put", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("put", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndPut struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndPut) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CheckAndPutArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CheckAndPutResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckAndPut(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.Put); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndPut: "+err2.Error())
			oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("checkAndPut", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorPutMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorPutMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := PutMultipleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("putMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := PutMultipleResult{}
	var err2 error
	if err2 = p.handler.PutMultiple(args.Table, args.Puts); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing putMultiple: "+err2.Error())
			oprot.WriteMessageBegin("putMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("putMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteSingle struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteSingle) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteSingleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteSingle", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteSingleResult{}
	var err2 error
	if err2 = p.handler.DeleteSingle(args.Table, args.DeleteSingle); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteSingle: "+err2.Error())
			oprot.WriteMessageBegin("deleteSingle", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteSingle", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorDeleteMultiple struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorDeleteMultiple) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteMultipleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteMultiple", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteMultipleResult{}
	var err2 error
	if result.Success, err2 = p.handler.DeleteMultiple(args.Table, args.Deletes); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteMultiple: "+err2.Error())
			oprot.WriteMessageBegin("deleteMultiple", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteMultiple", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCheckAndDelete struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCheckAndDelete) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CheckAndDeleteArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndDelete", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CheckAndDeleteResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckAndDelete(args.Table, args.Row, args.Family, args.Qualifier, args.Value, args.DeleteSingle); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndDelete: "+err2.Error())
			oprot.WriteMessageBegin("checkAndDelete", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("checkAndDelete", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorIncrement struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorIncrement) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IncrementArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IncrementResult{}
	var err2 error
	if result.Success, err2 = p.handler.Increment(args.Table, args.Increment); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: "+err2.Error())
			oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("increment", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorAppend struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorAppend) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AppendArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("append", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AppendResult{}
	var err2 error
	if result.Success, err2 = p.handler.Append(args.Table, args.Append); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing append: "+err2.Error())
			oprot.WriteMessageBegin("append", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("append", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorOpenScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorOpenScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := OpenScannerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("openScanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := OpenScannerResult{}
	var retval int32
	var err2 error
	if retval, err2 = p.handler.OpenScanner(args.Table, args.Scan); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing openScanner: "+err2.Error())
			oprot.WriteMessageBegin("openScanner", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	result.Success = &retval
	if err2 = oprot.WriteMessageBegin("openScanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerRows struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerRows) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetScannerRowsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getScannerRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetScannerRowsResult{}
	var err2 error
	if result.Success, err2 = p.handler.GetScannerRows(args.ScannerId, args.NumRows); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerRows: "+err2.Error())
			oprot.WriteMessageBegin("getScannerRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getScannerRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorCloseScanner struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorCloseScanner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CloseScannerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("closeScanner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CloseScannerResult{}
	var err2 error
	if err2 = p.handler.CloseScanner(args.ScannerId); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		case *TIllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing closeScanner: "+err2.Error())
			oprot.WriteMessageBegin("closeScanner", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("closeScanner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorMutateRow struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorMutateRow) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MutateRowArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MutateRowResult{}
	var err2 error
	if err2 = p.handler.MutateRow(args.Table, args.RowMutations); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRow: "+err2.Error())
			oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type tHBaseServiceProcessorGetScannerResults struct {
	handler THBaseService
}

func (p *tHBaseServiceProcessorGetScannerResults) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetScannerResultsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getScannerResults", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetScannerResultsResult{}
	var err2 error
	if result.Success, err2 = p.handler.GetScannerResults(args.Table, args.Scan, args.NumRows); err2 != nil {
		switch v := err2.(type) {
		case *TIOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getScannerResults: "+err2.Error())
			oprot.WriteMessageBegin("getScannerResults", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("getScannerResults", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type ExistsArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Get   *TGet  `thrift:"get,2,required" json:"get"`
}

func NewExistsArgs() *ExistsArgs {
	return &ExistsArgs{}
}

func (p *ExistsArgs) GetTable() []byte {
	return p.Table
}

var ExistsArgs_Get_DEFAULT *TGet

func (p *ExistsArgs) GetGet() *TGet {
	if !p.IsSetGet() {
		return ExistsArgs_Get_DEFAULT
	}
	return p.Get
}
func (p *ExistsArgs) IsSetGet() bool {
	return p.Get != nil
}

func (p *ExistsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *ExistsArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Get = &TGet{}
	if err := p.Get.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Get, err)
	}
	return nil
}

func (p *ExistsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *ExistsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("get", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:get: %s", p, err)
	}
	if err := p.Get.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Get, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:get: %s", p, err)
	}
	return err
}

func (p *ExistsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsArgs(%+v)", *p)
}

type ExistsResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewExistsResult() *ExistsResult {
	return &ExistsResult{}
}

var ExistsResult_Success_DEFAULT bool

func (p *ExistsResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return ExistsResult_Success_DEFAULT
	}
	return *p.Success
}

var ExistsResult_Io_DEFAULT *TIOError

func (p *ExistsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return ExistsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ExistsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExistsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ExistsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExistsResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *ExistsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ExistsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("exists_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExistsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExistsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ExistsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExistsResult(%+v)", *p)
}

type GetArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Get   *TGet  `thrift:"get,2,required" json:"get"`
}

func NewGetArgs() *GetArgs {
	return &GetArgs{}
}

func (p *GetArgs) GetTable() []byte {
	return p.Table
}

var GetArgs_Get_DEFAULT *TGet

func (p *GetArgs) GetGet() *TGet {
	if !p.IsSetGet() {
		return GetArgs_Get_DEFAULT
	}
	return p.Get
}
func (p *GetArgs) IsSetGet() bool {
	return p.Get != nil
}

func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Get = &TGet{}
	if err := p.Get.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Get, err)
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *GetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("get", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:get: %s", p, err)
	}
	if err := p.Get.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Get, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:get: %s", p, err)
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success *TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewGetResult() *GetResult {
	return &GetResult{}
}

var GetResult_Success_DEFAULT *TResult_

func (p *GetResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return GetResult_Success_DEFAULT
	}
	return p.Success
}

var GetResult_Io_DEFAULT *TIOError

func (p *GetResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type GetMultipleArgs struct {
	Table []byte  `thrift:"table,1,required" json:"table"`
	Gets  []*TGet `thrift:"gets,2,required" json:"gets"`
}

func NewGetMultipleArgs() *GetMultipleArgs {
	return &GetMultipleArgs{}
}

func (p *GetMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *GetMultipleArgs) GetGets() []*TGet {
	return p.Gets
}
func (p *GetMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMultipleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetMultipleArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TGet, 0, size)
	p.Gets = tSlice
	for i := 0; i < size; i++ {
		_elem55 := &TGet{}
		if err := _elem55.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem55, err)
		}
		p.Gets = append(p.Gets, _elem55)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMultiple_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *GetMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("gets", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:gets: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Gets)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Gets {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:gets: %s", p, err)
	}
	return err
}

func (p *GetMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMultipleArgs(%+v)", *p)
}

type GetMultipleResult struct {
	Success []*TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError   `thrift:"io,1" json:"io"`
}

func NewGetMultipleResult() *GetMultipleResult {
	return &GetMultipleResult{}
}

var GetMultipleResult_Success_DEFAULT []*TResult_

func (p *GetMultipleResult) GetSuccess() []*TResult_ {
	return p.Success
}

var GetMultipleResult_Io_DEFAULT *TIOError

func (p *GetMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetMultipleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetMultipleResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem56 := &TResult_{}
		if err := _elem56.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem56, err)
		}
		p.Success = append(p.Success, _elem56)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetMultipleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getMultiple_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetMultipleResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetMultipleResult(%+v)", *p)
}

type PutArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Put   *TPut  `thrift:"put,2,required" json:"put"`
}

func NewPutArgs() *PutArgs {
	return &PutArgs{}
}

func (p *PutArgs) GetTable() []byte {
	return p.Table
}

var PutArgs_Put_DEFAULT *TPut

func (p *PutArgs) GetPut() *TPut {
	if !p.IsSetPut() {
		return PutArgs_Put_DEFAULT
	}
	return p.Put
}
func (p *PutArgs) IsSetPut() bool {
	return p.Put != nil
}

func (p *PutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *PutArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Put = &TPut{}
	if err := p.Put.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Put, err)
	}
	return nil
}

func (p *PutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *PutArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("put", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:put: %s", p, err)
	}
	if err := p.Put.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Put, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:put: %s", p, err)
	}
	return err
}

func (p *PutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutArgs(%+v)", *p)
}

type PutResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewPutResult() *PutResult {
	return &PutResult{}
}

var PutResult_Io_DEFAULT *TIOError

func (p *PutResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return PutResult_Io_DEFAULT
	}
	return p.Io
}
func (p *PutResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *PutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *PutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("put_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *PutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutResult(%+v)", *p)
}

type CheckAndPutArgs struct {
	Table     []byte `thrift:"table,1,required" json:"table"`
	Row       []byte `thrift:"row,2,required" json:"row"`
	Family    []byte `thrift:"family,3,required" json:"family"`
	Qualifier []byte `thrift:"qualifier,4,required" json:"qualifier"`
	Value     []byte `thrift:"value,5" json:"value"`
	Put       *TPut  `thrift:"put,6,required" json:"put"`
}

func NewCheckAndPutArgs() *CheckAndPutArgs {
	return &CheckAndPutArgs{}
}

func (p *CheckAndPutArgs) GetTable() []byte {
	return p.Table
}

func (p *CheckAndPutArgs) GetRow() []byte {
	return p.Row
}

func (p *CheckAndPutArgs) GetFamily() []byte {
	return p.Family
}

func (p *CheckAndPutArgs) GetQualifier() []byte {
	return p.Qualifier
}

func (p *CheckAndPutArgs) GetValue() []byte {
	return p.Value
}

var CheckAndPutArgs_Put_DEFAULT *TPut

func (p *CheckAndPutArgs) GetPut() *TPut {
	if !p.IsSetPut() {
		return CheckAndPutArgs_Put_DEFAULT
	}
	return p.Put
}
func (p *CheckAndPutArgs) IsSetPut() bool {
	return p.Put != nil
}

func (p *CheckAndPutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField6(iprot thrift.TProtocol) error {
	p.Put = &TPut{}
	if err := p.Put.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Put, err)
	}
	return nil
}

func (p *CheckAndPutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndPutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Family); err != nil {
		return fmt.Errorf("%T.family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:family: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:qualifier: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Qualifier); err != nil {
		return fmt.Errorf("%T.qualifier (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:qualifier: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:value: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return fmt.Errorf("%T.value (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:value: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("put", thrift.STRUCT, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:put: %s", p, err)
	}
	if err := p.Put.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Put, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:put: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndPutArgs(%+v)", *p)
}

type CheckAndPutResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewCheckAndPutResult() *CheckAndPutResult {
	return &CheckAndPutResult{}
}

var CheckAndPutResult_Success_DEFAULT bool

func (p *CheckAndPutResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return CheckAndPutResult_Success_DEFAULT
	}
	return *p.Success
}

var CheckAndPutResult_Io_DEFAULT *TIOError

func (p *CheckAndPutResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return CheckAndPutResult_Io_DEFAULT
	}
	return p.Io
}
func (p *CheckAndPutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CheckAndPutResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CheckAndPutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndPutResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CheckAndPutResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CheckAndPutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndPutResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndPutResult(%+v)", *p)
}

type PutMultipleArgs struct {
	Table []byte  `thrift:"table,1,required" json:"table"`
	Puts  []*TPut `thrift:"puts,2,required" json:"puts"`
}

func NewPutMultipleArgs() *PutMultipleArgs {
	return &PutMultipleArgs{}
}

func (p *PutMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *PutMultipleArgs) GetPuts() []*TPut {
	return p.Puts
}
func (p *PutMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutMultipleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *PutMultipleArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TPut, 0, size)
	p.Puts = tSlice
	for i := 0; i < size; i++ {
		_elem57 := &TPut{}
		if err := _elem57.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem57, err)
		}
		p.Puts = append(p.Puts, _elem57)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *PutMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("putMultiple_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *PutMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("puts", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:puts: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Puts)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Puts {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:puts: %s", p, err)
	}
	return err
}

func (p *PutMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutMultipleArgs(%+v)", *p)
}

type PutMultipleResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewPutMultipleResult() *PutMultipleResult {
	return &PutMultipleResult{}
}

var PutMultipleResult_Io_DEFAULT *TIOError

func (p *PutMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return PutMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *PutMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *PutMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PutMultipleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *PutMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("putMultiple_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *PutMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *PutMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PutMultipleResult(%+v)", *p)
}

type DeleteSingleArgs struct {
	Table        []byte   `thrift:"table,1,required" json:"table"`
	DeleteSingle *TDelete `thrift:"deleteSingle,2,required" json:"deleteSingle"`
}

func NewDeleteSingleArgs() *DeleteSingleArgs {
	return &DeleteSingleArgs{}
}

func (p *DeleteSingleArgs) GetTable() []byte {
	return p.Table
}

var DeleteSingleArgs_DeleteSingle_DEFAULT *TDelete

func (p *DeleteSingleArgs) GetDeleteSingle() *TDelete {
	if !p.IsSetDeleteSingle() {
		return DeleteSingleArgs_DeleteSingle_DEFAULT
	}
	return p.DeleteSingle
}
func (p *DeleteSingleArgs) IsSetDeleteSingle() bool {
	return p.DeleteSingle != nil
}

func (p *DeleteSingleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteSingleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *DeleteSingleArgs) ReadField2(iprot thrift.TProtocol) error {
	p.DeleteSingle = &TDelete{
		DeleteType: 1,
	}
	if err := p.DeleteSingle.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.DeleteSingle, err)
	}
	return nil
}

func (p *DeleteSingleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteSingle_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteSingleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *DeleteSingleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deleteSingle", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:deleteSingle: %s", p, err)
	}
	if err := p.DeleteSingle.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.DeleteSingle, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:deleteSingle: %s", p, err)
	}
	return err
}

func (p *DeleteSingleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteSingleArgs(%+v)", *p)
}

type DeleteSingleResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

//NewDeleteSingleResult for single
func NewDeleteSingleResult() *DeleteSingleResult {
	return &DeleteSingleResult{}
}

//DeleteSingleResultIoDEFAULT for default
var DeleteSingleResultIoDEFAULT *TIOError

//GetIo for go io
func (p *DeleteSingleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return DeleteSingleResultIoDEFAULT
	}
	return p.Io
}

//IsSetIo for set io
func (p *DeleteSingleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteSingleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteSingleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteSingleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteSingle_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteSingleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteSingleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteSingleResult(%+v)", *p)
}

type DeleteMultipleArgs struct {
	Table   []byte     `thrift:"table,1,required" json:"table"`
	Deletes []*TDelete `thrift:"deletes,2,required" json:"deletes"`
}

func NewDeleteMultipleArgs() *DeleteMultipleArgs {
	return &DeleteMultipleArgs{}
}

func (p *DeleteMultipleArgs) GetTable() []byte {
	return p.Table
}

func (p *DeleteMultipleArgs) GetDeletes() []*TDelete {
	return p.Deletes
}
func (p *DeleteMultipleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteMultipleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *DeleteMultipleArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Deletes = tSlice
	for i := 0; i < size; i++ {
		_elem58 := &TDelete{
			DeleteType: 1,
		}
		if err := _elem58.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem58, err)
		}
		p.Deletes = append(p.Deletes, _elem58)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DeleteMultipleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteMultiple_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteMultipleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *DeleteMultipleArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deletes", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:deletes: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Deletes)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Deletes {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:deletes: %s", p, err)
	}
	return err
}

func (p *DeleteMultipleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteMultipleArgs(%+v)", *p)
}

type DeleteMultipleResult struct {
	Success []*TDelete `thrift:"success,0" json:"success"`
	Io      *TIOError  `thrift:"io,1" json:"io"`
}

func NewDeleteMultipleResult() *DeleteMultipleResult {
	return &DeleteMultipleResult{}
}

var DeleteMultipleResult_Success_DEFAULT []*TDelete

func (p *DeleteMultipleResult) GetSuccess() []*TDelete {
	return p.Success
}

var DeleteMultipleResult_Io_DEFAULT *TIOError

func (p *DeleteMultipleResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return DeleteMultipleResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteMultipleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DeleteMultipleResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteMultipleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteMultipleResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TDelete, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem59 := &TDelete{
			DeleteType: 1,
		}
		if err := _elem59.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem59, err)
		}
		p.Success = append(p.Success, _elem59)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *DeleteMultipleResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteMultipleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteMultiple_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteMultipleResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DeleteMultipleResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteMultipleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteMultipleResult(%+v)", *p)
}

type CheckAndDeleteArgs struct {
	Table        []byte   `thrift:"table,1,required" json:"table"`
	Row          []byte   `thrift:"row,2,required" json:"row"`
	Family       []byte   `thrift:"family,3,required" json:"family"`
	Qualifier    []byte   `thrift:"qualifier,4,required" json:"qualifier"`
	Value        []byte   `thrift:"value,5" json:"value"`
	DeleteSingle *TDelete `thrift:"deleteSingle,6,required" json:"deleteSingle"`
}

func NewCheckAndDeleteArgs() *CheckAndDeleteArgs {
	return &CheckAndDeleteArgs{}
}

func (p *CheckAndDeleteArgs) GetTable() []byte {
	return p.Table
}

func (p *CheckAndDeleteArgs) GetRow() []byte {
	return p.Row
}

func (p *CheckAndDeleteArgs) GetFamily() []byte {
	return p.Family
}

func (p *CheckAndDeleteArgs) GetQualifier() []byte {
	return p.Qualifier
}

//GetValue for get val
func (p *CheckAndDeleteArgs) GetValue() []byte {
	return p.Value
}

var CheckAndDeleteArgs_DeleteSingle_DEFAULT *TDelete

func (p *CheckAndDeleteArgs) GetDeleteSingle() *TDelete {
	if !p.IsSetDeleteSingle() {
		return CheckAndDeleteArgs_DeleteSingle_DEFAULT
	}
	return p.DeleteSingle
}
func (p *CheckAndDeleteArgs) IsSetDeleteSingle() bool {
	return p.DeleteSingle != nil
}

func (p *CheckAndDeleteArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Row = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Family = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Qualifier = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *CheckAndDeleteArgs) ReadField6(iprot thrift.TProtocol) error {
	p.DeleteSingle = &TDelete{
		DeleteType: 1,
	}
	if err := p.DeleteSingle.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.DeleteSingle, err)
	}
	return nil
}

func (p *CheckAndDeleteArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndDelete_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndDeleteArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Family); err != nil {
		return fmt.Errorf("%T.family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:family: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("qualifier", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:qualifier: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Qualifier); err != nil {
		return fmt.Errorf("%T.qualifier (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:qualifier: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:value: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return fmt.Errorf("%T.value (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:value: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deleteSingle", thrift.STRUCT, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:deleteSingle: %s", p, err)
	}
	if err := p.DeleteSingle.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.DeleteSingle, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:deleteSingle: %s", p, err)
	}
	return err
}

func (p *CheckAndDeleteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndDeleteArgs(%+v)", *p)
}

type CheckAndDeleteResult struct {
	Success *bool     `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewCheckAndDeleteResult() *CheckAndDeleteResult {
	return &CheckAndDeleteResult{}
}

var CheckAndDeleteResult_Success_DEFAULT bool

func (p *CheckAndDeleteResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return CheckAndDeleteResult_Success_DEFAULT
	}
	return *p.Success
}

var CheckAndDeleteResult_Io_DEFAULT *TIOError

func (p *CheckAndDeleteResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return CheckAndDeleteResult_Io_DEFAULT
	}
	return p.Io
}
func (p *CheckAndDeleteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CheckAndDeleteResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CheckAndDeleteResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndDeleteResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CheckAndDeleteResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CheckAndDeleteResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndDelete_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndDeleteResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndDeleteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndDeleteResult(%+v)", *p)
}

type IncrementArgs struct {
	Table     []byte      `thrift:"table,1,required" json:"table"`
	Increment *TIncrement `thrift:"increment,2,required" json:"increment"`
}

func NewIncrementArgs() *IncrementArgs {
	return &IncrementArgs{}
}

func (p *IncrementArgs) GetTable() []byte {
	return p.Table
}

var IncrementArgs_Increment_DEFAULT *TIncrement

func (p *IncrementArgs) GetIncrement() *TIncrement {
	if !p.IsSetIncrement() {
		return IncrementArgs_Increment_DEFAULT
	}
	return p.Increment
}
func (p *IncrementArgs) IsSetIncrement() bool {
	return p.Increment != nil
}

func (p *IncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *IncrementArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Increment = &TIncrement{}
	if err := p.Increment.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Increment, err)
	}
	return nil
}

func (p *IncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *IncrementArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("increment", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:increment: %s", p, err)
	}
	if err := p.Increment.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Increment, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:increment: %s", p, err)
	}
	return err
}

func (p *IncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementArgs(%+v)", *p)
}

type IncrementResult struct {
	Success *TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewIncrementResult() *IncrementResult {
	return &IncrementResult{}
}

var IncrementResult_Success_DEFAULT *TResult_

func (p *IncrementResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return IncrementResult_Success_DEFAULT
	}
	return p.Success
}

var IncrementResult_Io_DEFAULT *TIOError

func (p *IncrementResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return IncrementResult_Io_DEFAULT
	}
	return p.Io
}
func (p *IncrementResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IncrementResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *IncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *IncrementResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementResult(%+v)", *p)
}

type AppendArgs struct {
	Table  []byte   `thrift:"table,1,required" json:"table"`
	Append *TAppend `thrift:"append,2,required" json:"append"`
}

func NewAppendArgs() *AppendArgs {
	return &AppendArgs{}
}

func (p *AppendArgs) GetTable() []byte {
	return p.Table
}

var AppendArgs_Append_DEFAULT *TAppend

func (p *AppendArgs) GetAppend() *TAppend {
	if !p.IsSetAppend() {
		return AppendArgs_Append_DEFAULT
	}
	return p.Append
}
func (p *AppendArgs) IsSetAppend() bool {
	return p.Append != nil
}

func (p *AppendArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AppendArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *AppendArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Append = &TAppend{}
	if err := p.Append.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Append, err)
	}
	return nil
}

func (p *AppendArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("append_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AppendArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *AppendArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("append", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:append: %s", p, err)
	}
	if err := p.Append.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Append, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:append: %s", p, err)
	}
	return err
}

func (p *AppendArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AppendArgs(%+v)", *p)
}

type AppendResult struct {
	Success *TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewAppendResult() *AppendResult {
	return &AppendResult{}
}

var AppendResult_Success_DEFAULT *TResult_

func (p *AppendResult) GetSuccess() *TResult_ {
	if !p.IsSetSuccess() {
		return AppendResult_Success_DEFAULT
	}
	return p.Success
}

var AppendResult_Io_DEFAULT *TIOError

func (p *AppendResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return AppendResult_Io_DEFAULT
	}
	return p.Io
}
func (p *AppendResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppendResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *AppendResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AppendResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *AppendResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *AppendResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("append_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AppendResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AppendResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *AppendResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AppendResult(%+v)", *p)
}

type OpenScannerArgs struct {
	Table []byte `thrift:"table,1,required" json:"table"`
	Scan  *TScan `thrift:"scan,2,required" json:"scan"`
}

func NewOpenScannerArgs() *OpenScannerArgs {
	return &OpenScannerArgs{}
}

func (p *OpenScannerArgs) GetTable() []byte {
	return p.Table
}

var OpenScannerArgs_Scan_DEFAULT *TScan

func (p *OpenScannerArgs) GetScan() *TScan {
	if !p.IsSetScan() {
		return OpenScannerArgs_Scan_DEFAULT
	}
	return p.Scan
}
func (p *OpenScannerArgs) IsSetScan() bool {
	return p.Scan != nil
}

func (p *OpenScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *OpenScannerArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Scan = &TScan{
		MaxVersions: 1,
	}
	if err := p.Scan.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Scan, err)
	}
	return nil
}

func (p *OpenScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openScanner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *OpenScannerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scan", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:scan: %s", p, err)
	}
	if err := p.Scan.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Scan, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:scan: %s", p, err)
	}
	return err
}

func (p *OpenScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerArgs(%+v)", *p)
}

type OpenScannerResult struct {
	Success *int32    `thrift:"success,0" json:"success"`
	Io      *TIOError `thrift:"io,1" json:"io"`
}

func NewOpenScannerResult() *OpenScannerResult {
	return &OpenScannerResult{}
}

var OpenScannerResult_Success_DEFAULT int32

func (p *OpenScannerResult) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return OpenScannerResult_Success_DEFAULT
	}
	return *p.Success
}

var OpenScannerResult_Io_DEFAULT *TIOError

func (p *OpenScannerResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return OpenScannerResult_Io_DEFAULT
	}
	return p.Io
}
func (p *OpenScannerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *OpenScannerResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *OpenScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *OpenScannerResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *OpenScannerResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *OpenScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("openScanner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *OpenScannerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *OpenScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("OpenScannerResult(%+v)", *p)
}

type GetScannerRowsArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required" json:"scannerId"`
	NumRows   int32 `thrift:"numRows,2" json:"numRows"`
}

func NewGetScannerRowsArgs() *GetScannerRowsArgs {
	return &GetScannerRowsArgs{
		NumRows: 1,
	}
}

func (p *GetScannerRowsArgs) GetScannerId() int32 {
	return p.ScannerId
}

func (p *GetScannerRowsArgs) GetNumRows() int32 {
	return p.NumRows
}
func (p *GetScannerRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerRowsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *GetScannerRowsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *GetScannerRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scannerId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scannerId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ScannerId)); err != nil {
		return fmt.Errorf("%T.scannerId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scannerId: %s", p, err)
	}
	return err
}

func (p *GetScannerRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numRows", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:numRows: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumRows)); err != nil {
		return fmt.Errorf("%T.numRows (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:numRows: %s", p, err)
	}
	return err
}

func (p *GetScannerRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerRowsArgs(%+v)", *p)
}

type GetScannerRowsResult struct {
	Success []*TResult_       `thrift:"success,0" json:"success"`
	Io      *TIOError         `thrift:"io,1" json:"io"`
	Ia      *TIllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewGetScannerRowsResult() *GetScannerRowsResult {
	return &GetScannerRowsResult{}
}

var GetScannerRowsResult_Success_DEFAULT []*TResult_

func (p *GetScannerRowsResult) GetSuccess() []*TResult_ {
	return p.Success
}

var GetScannerRowsResult_Io_DEFAULT *TIOError

func (p *GetScannerRowsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetScannerRowsResult_Io_DEFAULT
	}
	return p.Io
}

var GetScannerRowsResult_Ia_DEFAULT *TIllegalArgument

func (p *GetScannerRowsResult) GetIa() *TIllegalArgument {
	if !p.IsSetIa() {
		return GetScannerRowsResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *GetScannerRowsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetScannerRowsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetScannerRowsResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *GetScannerRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerRowsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem60 := &TResult_{}
		if err := _elem60.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem60, err)
		}
		p.Success = append(p.Success, _elem60)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetScannerRowsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetScannerRowsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &TIllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *GetScannerRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerRowsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerRowsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerRowsResult(%+v)", *p)
}

type CloseScannerArgs struct {
	ScannerId int32 `thrift:"scannerId,1,required" json:"scannerId"`
}

func NewCloseScannerArgs() *CloseScannerArgs {
	return &CloseScannerArgs{}
}

func (p *CloseScannerArgs) GetScannerId() int32 {
	return p.ScannerId
}
func (p *CloseScannerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.ScannerId = v
	}
	return nil
}

func (p *CloseScannerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeScanner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scannerId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:scannerId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ScannerId)); err != nil {
		return fmt.Errorf("%T.scannerId (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:scannerId: %s", p, err)
	}
	return err
}

func (p *CloseScannerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerArgs(%+v)", *p)
}

type CloseScannerResult struct {
	Io *TIOError         `thrift:"io,1" json:"io"`
	Ia *TIllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewCloseScannerResult() *CloseScannerResult {
	return &CloseScannerResult{}
}

var CloseScannerResult_Io_DEFAULT *TIOError

func (p *CloseScannerResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return CloseScannerResult_Io_DEFAULT
	}
	return p.Io
}

var CloseScannerResult_Ia_DEFAULT *TIllegalArgument

func (p *CloseScannerResult) GetIa() *TIllegalArgument {
	if !p.IsSetIa() {
		return CloseScannerResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *CloseScannerResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CloseScannerResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *CloseScannerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseScannerResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CloseScannerResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &TIllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *CloseScannerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("closeScanner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseScannerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CloseScannerResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *CloseScannerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseScannerResult(%+v)", *p)
}

type MutateRowArgs struct {
	Table        []byte         `thrift:"table,1,required" json:"table"`
	RowMutations *TRowMutations `thrift:"rowMutations,2,required" json:"rowMutations"`
}

func NewMutateRowArgs() *MutateRowArgs {
	return &MutateRowArgs{}
}

func (p *MutateRowArgs) GetTable() []byte {
	return p.Table
}

var MutateRowArgs_RowMutations_DEFAULT *TRowMutations

func (p *MutateRowArgs) GetRowMutations() *TRowMutations {
	if !p.IsSetRowMutations() {
		return MutateRowArgs_RowMutations_DEFAULT
	}
	return p.RowMutations
}
func (p *MutateRowArgs) IsSetRowMutations() bool {
	return p.RowMutations != nil
}

func (p *MutateRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *MutateRowArgs) ReadField2(iprot thrift.TProtocol) error {
	p.RowMutations = &TRowMutations{}
	if err := p.RowMutations.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.RowMutations, err)
	}
	return nil
}

func (p *MutateRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *MutateRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rowMutations", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:rowMutations: %s", p, err)
	}
	if err := p.RowMutations.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.RowMutations, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:rowMutations: %s", p, err)
	}
	return err
}

func (p *MutateRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowArgs(%+v)", *p)
}

type MutateRowResult struct {
	Io *TIOError `thrift:"io,1" json:"io"`
}

func NewMutateRowResult() *MutateRowResult {
	return &MutateRowResult{}
}

var MutateRowResult_Io_DEFAULT *TIOError

func (p *MutateRowResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return MutateRowResult_Io_DEFAULT
	}
	return p.Io
}
func (p *MutateRowResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *MutateRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowResult(%+v)", *p)
}

type GetScannerResultsArgs struct {
	Table   []byte `thrift:"table,1,required" json:"table"`
	Scan    *TScan `thrift:"scan,2,required" json:"scan"`
	NumRows int32  `thrift:"numRows,3" json:"numRows"`
}

func NewGetScannerResultsArgs() *GetScannerResultsArgs {
	return &GetScannerResultsArgs{
		NumRows: 1,
	}
}

func (p *GetScannerResultsArgs) GetTable() []byte {
	return p.Table
}

var GetScannerResultsArgs_Scan_DEFAULT *TScan

func (p *GetScannerResultsArgs) GetScan() *TScan {
	if !p.IsSetScan() {
		return GetScannerResultsArgs_Scan_DEFAULT
	}
	return p.Scan
}

func (p *GetScannerResultsArgs) GetNumRows() int32 {
	return p.NumRows
}
func (p *GetScannerResultsArgs) IsSetScan() bool {
	return p.Scan != nil
}

func (p *GetScannerResultsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerResultsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Table = v
	}
	return nil
}

func (p *GetScannerResultsArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Scan = &TScan{
		MaxVersions: 1,
	}
	if err := p.Scan.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Scan, err)
	}
	return nil
}

func (p *GetScannerResultsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.NumRows = v
	}
	return nil
}

func (p *GetScannerResultsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerResults_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerResultsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("table", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:table: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Table); err != nil {
		return fmt.Errorf("%T.table (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:table: %s", p, err)
	}
	return err
}

func (p *GetScannerResultsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scan", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:scan: %s", p, err)
	}
	if err := p.Scan.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Scan, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:scan: %s", p, err)
	}
	return err
}

func (p *GetScannerResultsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numRows", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:numRows: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumRows)); err != nil {
		return fmt.Errorf("%T.numRows (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:numRows: %s", p, err)
	}
	return err
}

func (p *GetScannerResultsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerResultsArgs(%+v)", *p)
}

type GetScannerResultsResult struct {
	Success []*TResult_ `thrift:"success,0" json:"success"`
	Io      *TIOError   `thrift:"io,1" json:"io"`
}

func NewGetScannerResultsResult() *GetScannerResultsResult {
	return &GetScannerResultsResult{}
}

var GetScannerResultsResult_Success_DEFAULT []*TResult_

func (p *GetScannerResultsResult) GetSuccess() []*TResult_ {
	return p.Success
}

var GetScannerResultsResult_Io_DEFAULT *TIOError

func (p *GetScannerResultsResult) GetIo() *TIOError {
	if !p.IsSetIo() {
		return GetScannerResultsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetScannerResultsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetScannerResultsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetScannerResultsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeID, fieldID, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldID, err)
		}
		if fieldTypeID == thrift.STOP {
			break
		}
		switch fieldID {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeID); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetScannerResultsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem61 := &TResult_{}
		if err := _elem61.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem61, err)
		}
		p.Success = append(p.Success, _elem61)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetScannerResultsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &TIOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetScannerResultsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getScannerResults_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetScannerResultsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerResultsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetScannerResultsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetScannerResultsResult(%+v)", *p)
}
